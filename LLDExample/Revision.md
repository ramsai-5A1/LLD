

# Backend Development 
# Season-1 
    1. History of Node 
    2. Ecmascript 
    3. windows, self, frames, this, global, globalThis 
    4. CommonJS & ES6 modules 
    5. IIFE 
    6. Sync and Async IO (call stack, memory heap, garbage collector)
    7. Code 
    8. Internals of V8 engine (Ignition Intrepretor, Turbofan compiler, Byte code, hot code)
    9. Internals of libuv (Event loop --> Timer (setTimeout, setInterval), poll (file-read, api-calls), check (setImmediate), close (websocket connection), process.nextTick(), promise callbacks)
    10. Thread pool, how libuv interacts with OS 
    11. Web dev fundamentals + Startingn our express server 
    12. Mysql vs NoSql 
    13. Connecting with MongoDB


# Season-2 
    1. Monolith vs Microservices 
    2. LLD, HLD, API Design, DB Design 
    3. Starting our express server + Mongoose 
    4. Routes + Request handler 
    5. Middlewares + Error handler 
    6. Database, Schema, Models 
    7. CRUD 
    8. Data sanitization, Schema validation 
    9. Encrypting passwords 
    10. Authentication, JWT & Cookies 
    11. Express Router 
    12. 'pre' middleware + Compound indexing 
    13. 'ref' and 'populate' 
    14. pagination (.skip().limit())

    15. vite + react, tailwindcss, daisyUI, react-router-dom
    16. Redux toolkit
    17. Integrating with Backend apis
    18. 
    19. 



# System-Design 
# Gaurav-Sen 
    1. Horizontal vs Vertical Scaling 
    2. Monolith vs Microservices 
    3. Load balancer (round robin, geo based approach, least connection)
    4. Sharding 
    5. Single point failure (Multiple app servers, Master-Slave architecture)
    6. Health checkup + Service Discovery 
    7. Back of the envelope estimation (Traffic, Storage, Bandwidth, Cache)
    8. Content Delivery Networks 


# Sanket-Singh 
    0. Abstract classes & Interfaces 
    1. Single-Responsibility Principle 
    2. Open-Closed Principle 
    3. Liskov-Subsitution Principle 
    4. Interface-Segregation Principle 
    5. Dependency-Inversion Principle


# Design Patterns 
    # Creational DP 
        1. Builder DP 
        2. Singleton DP (early initilization, lazy initilization, synchronized method, sync block, inner static class with final variable, enum)
        3. Factory DP 
        4. Abstract Factory DP 
        5. Prototype DP (Shallow copy, Deep copy)

    # Behavioural DP 
        1. Observer DP (Observable, Observer)
        2. Iterator DP (hasNext(), next())
        3. Strategy DP (Multiple childs having same implementation, its better to keep them seperately and extend)

    # Structural DP
        1. Adapter DP (works with Incompatible interfaces)




## Resources i am following
    1. Akshay Saini (Full stack Dev (MERN stack))
    2. Sanket Singh (Backend Dev in java + System Design in java)
    3. Harkirat Singh (Full stack Dev (MERN Stac)k)
    4. Gaurav-Sen (System Design)
    5. CodeWithDurgesh (System Design in java)
    6. Shreyansh Jain (Backend Dev + System Design in java)
    7. Raj-Vikramadithya (Data structures & Algorithms)



